{"ast":null,"code":"import _classCallCheck from \"/Users/umas/my-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/umas/my-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/umas/my-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/umas/my-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/umas/my-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/umas/my-app/src/TextApp.jsx\";\nimport React, { Component } from 'react';\nimport TextShow from './TextShow';\nimport TextInput from './TextInput';\n\nvar TextApp =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(TextApp, _Component);\n\n  function TextApp(props) {\n    var _this;\n\n    _classCallCheck(this, TextApp);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextApp).call(this, props));\n\n    _this.onClickAction = function () {\n      console.log('you just clicked me');\n    };\n\n    _this.setStyle = function () {\n      return {\n        height: 200 + 'px'\n      };\n    };\n\n    _this.setPlaceholder = function () {\n      return 'Ha Ha!';\n    };\n\n    _this.onChangeHandler = function (text) {\n      return function () {\n        _this.setState({\n          text: text\n        });\n\n        console.log(\"text in APP: \" + text);\n      };\n    };\n\n    _this.state = {\n      text: 'hahaha',\n      placeHolderText: '打字吧！'\n    };\n    return _this;\n  } //   getNewStyle = () => {\n  //     return {height:200+'px'}\n  //   }\n  //   getOnClickAction = () => {\n  //     console.log('you just clicked me')\n  // }\n  //   getPlaceholder = () => {\n  //     return 'hahaha'\n  //   }\n\n\n  _createClass(TextApp, [{\n    key: \"render\",\n    value: function render() {\n      return [React.createElement(TextShow, {\n        text: this.state.text,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 50\n        },\n        __self: this\n      }), React.createElement(TextInput, {\n        onClickHandler: this.onClickAction,\n        styleHandler: this.setStyle,\n        placeholderHandler: this.setPlaceholder(),\n        onChange: this.onChangeHandler,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 51\n        },\n        __self: this\n      })];\n    }\n  }]);\n\n  return TextApp;\n}(Component);\n\nexport default TextApp; //       {/* <TextInput onClickHandlRef={this.getOnClickAction} handleStyle={this.getNewStyle()} placeHolderRef={this.getPlaceholder()}></TextInput> */},\n// 在制定子元件的屬性為父元件的state值時，以函式表達式制定將帶表參照此函式\n// <TextShow text={this.state.text}></TextShow>\n// 但在寫函式表達式(fun = (a) => a)時，常數名稱不是放置傳入參數名稱的地方，等號右邊才是放入傳入參數名稱的地方\n// \n// 原則：呼叫props時使用使用函式定義式(function func() = {}}要加括號，呼叫常數時（包含函式表達式）不加括號\n// 原理：呼叫函式時，右邊不加括號與加括號的差別在於，加括號代表「使用」這個函式，不加括號代表「僅參照（Reference）」這個函式。父子元件溝通時，會參照很多函式，但會使用的函式至少要有一個，可能在子元件，可能在父元件。\n// 如果使用一個回調函式（使用函式，此函式回傳函式），表示回傳的函式將較晚執行。這造成一個情況會出問題：當子元件的onChange參照子元件onClickHandler函式，該函式log出來文字內容並使用為父元件的屬性中的函式，父元件的屬性參照父元件onClickHandler函式，該函式參照另一個函式指定其state中文字內容值，則state值將會跟log出來的字不同步，因為回調函式中，主函式先執行，回傳的函式後執行。\n// 如果你使用函式時，會執行函式並回傳結果。很多時候我在標籤上的函式加了括號，所以他就會執行函式，如果他還更新了state，就會重新render，於是又建立了標籤執行函式更動state又重新render，於是被拋出例外。解決問題的方法，就是將標籤裡的函式寫成回調函式，於是標籤裡只會執行這個函式並回傳你要的結果。\n// 子元件內部溝通時，不一定會「使用」函式，而可能只會參照函式，例如onChange\n// 子元件的JSX當中，可以使用子元件的函式表達式，來去參照父元件的JSX，而父元件的JSX，能夠「使用」父元件自己的函式表達式（像是用來呼叫其他子元件，或是回傳一個值）\n// 表單元件(如<input/>)一個規則：標籤的value屬性能夠讓元件能受控制(controled)，如果沒有設定value，代表此元件為不受控，這樣要是有一些功能如清空文字就會有困難\n// 子母元件三種溝通方式：\n// 1.直接定議子元件的值是父元件的屬性，父元件的屬性是父元件的state:\n// 子元件：\n// return <childElement style={props.parentAttribute}>\n// 父元件：\n// getStateValue = () => this.state.value\n// <parentElement style={this.getStateValue}>\n// 2.使用e.target.value取得\n// 子元件：\n// return <childInput></childInput>\n// 父元件：\n// getValue = (event) => console.log(event.target.value)    \n// <parentInput onClick={this.getValue}>\n// 3.使用refs\n// 子元件：\n// <childInput ref={props.getRefHandler}/>\n// 父元件：\n// getRef = (element) => this.inputElement = element\n// console.log(inputElemnt)\n// <parentInput getRefHandler={this.getRef}/>","map":{"version":3,"sources":["/Users/umas/my-app/src/TextApp.jsx"],"names":["React","Component","TextShow","TextInput","TextApp","props","onClickAction","console","log","setStyle","height","setPlaceholder","onChangeHandler","text","setState","state","placeHolderText"],"mappings":";;;;;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,OAAOC,SAAP,MAAsB,aAAtB;;IAEMC,O;;;;;AAEJ,mBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AACjB,iFAAMA,KAAN;;AADiB,UAoBnBC,aApBmB,GAoBH,YAAM;AACpBC,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAZ;AACD,KAtBkB;;AAAA,UAwBnBC,QAxBmB,GAwBR,YAAM;AACf,aAAO;AAACC,QAAAA,MAAM,EAAC,MAAM;AAAd,OAAP;AACD,KA1BkB;;AAAA,UA4BnBC,cA5BmB,GA4BF,YAAM;AACrB,aAAO,QAAP;AACD,KA9BkB;;AAAA,UAgCnBC,eAhCmB,GAgCD,UAACC,IAAD,EAAW;AAC3B,aAAO,YAAM;AACX,cAAKC,QAAL,CAAc;AAACD,UAAAA,IAAI,EAAEA;AAAP,SAAd;;AACAN,QAAAA,OAAO,CAACC,GAAR,CAAY,kBAAkBK,IAA9B;AACD,OAHD;AAKD,KAtCkB;;AAEjB,UAAKE,KAAL,GAAa;AACXF,MAAAA,IAAI,EAAE,QADK;AAEXG,MAAAA,eAAe,EAAE;AAFN,KAAb;AAFiB;AAMlB,G,CAEH;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;6BAsBW;AACP,aACE,CACA,oBAAC,QAAD;AAAU,QAAA,IAAI,EAAE,KAAKD,KAAL,CAAWF,IAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QADA,EAEE,oBAAC,SAAD;AAAW,QAAA,cAAc,EAAE,KAAKP,aAAhC;AAA+C,QAAA,YAAY,EAAE,KAAKG,QAAlE;AAA4E,QAAA,kBAAkB,EAAE,KAAKE,cAAL,EAAhG;AAAuH,QAAA,QAAQ,EAAE,KAAKC,eAAtI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAFF,CADF;AAMD;;;;EAjDmBX,S;;AAoDtB,eAAeG,OAAf,C,CAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACM;AACA;AACA;AACA;AACA;AACN;AACM;AACA;AACA;AACA;AACA;AACN;AACM;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import React, { Component } from 'react';\nimport TextShow from './TextShow'\nimport TextInput from './TextInput'\n\nclass TextApp extends Component {\n\n  constructor(props) {\n    super(props)\n    this.state = {\n      text: 'hahaha',\n      placeHolderText: '打字吧！'\n    }\n  }\n\n//   getNewStyle = () => {\n//     return {height:200+'px'}\n//   }\n\n//   getOnClickAction = () => {\n//     console.log('you just clicked me')\n// }\n\n//   getPlaceholder = () => {\n//     return 'hahaha'\n//   }\n\n  onClickAction = () => {\n    console.log('you just clicked me')\n  }\n\n  setStyle = () => {\n    return {height:200 + 'px'}\n  }\n\n  setPlaceholder = () => {\n    return 'Ha Ha!'\n  }\n\n  onChangeHandler = (text) =>  {    \n    return () => {\n      this.setState({text: text})\n      console.log(\"text in APP: \" + text)\n    }\n    \n  }\n  \n  render() {\n    return (\n      [\n      <TextShow text={this.state.text}></TextShow>,\n        <TextInput onClickHandler={this.onClickAction} styleHandler={this.setStyle} placeholderHandler={this.setPlaceholder()} onChange={this.onChangeHandler}></TextInput>\n      ]\n    )\n  }\n}\n\nexport default TextApp;\n\n//       {/* <TextInput onClickHandlRef={this.getOnClickAction} handleStyle={this.getNewStyle()} placeHolderRef={this.getPlaceholder()}></TextInput> */},\n\n// 在制定子元件的屬性為父元件的state值時，以函式表達式制定將帶表參照此函式\n// <TextShow text={this.state.text}></TextShow>\n// 但在寫函式表達式(fun = (a) => a)時，常數名稱不是放置傳入參數名稱的地方，等號右邊才是放入傳入參數名稱的地方\n// \n// 原則：呼叫props時使用使用函式定義式(function func() = {}}要加括號，呼叫常數時（包含函式表達式）不加括號\n\n// 原理：呼叫函式時，右邊不加括號與加括號的差別在於，加括號代表「使用」這個函式，不加括號代表「僅參照（Reference）」這個函式。父子元件溝通時，會參照很多函式，但會使用的函式至少要有一個，可能在子元件，可能在父元件。\n// 如果使用一個回調函式（使用函式，此函式回傳函式），表示回傳的函式將較晚執行。這造成一個情況會出問題：當子元件的onChange參照子元件onClickHandler函式，該函式log出來文字內容並使用為父元件的屬性中的函式，父元件的屬性參照父元件onClickHandler函式，該函式參照另一個函式指定其state中文字內容值，則state值將會跟log出來的字不同步，因為回調函式中，主函式先執行，回傳的函式後執行。\n// 如果你使用函式時，會執行函式並回傳結果。很多時候我在標籤上的函式加了括號，所以他就會執行函式，如果他還更新了state，就會重新render，於是又建立了標籤執行函式更動state又重新render，於是被拋出例外。解決問題的方法，就是將標籤裡的函式寫成回調函式，於是標籤裡只會執行這個函式並回傳你要的結果。\n// 子元件內部溝通時，不一定會「使用」函式，而可能只會參照函式，例如onChange\n// 子元件的JSX當中，可以使用子元件的函式表達式，來去參照父元件的JSX，而父元件的JSX，能夠「使用」父元件自己的函式表達式（像是用來呼叫其他子元件，或是回傳一個值）\n\n// 表單元件(如<input/>)一個規則：標籤的value屬性能夠讓元件能受控制(controled)，如果沒有設定value，代表此元件為不受控，這樣要是有一些功能如清空文字就會有困難\n\n// 子母元件三種溝通方式：\n// 1.直接定議子元件的值是父元件的屬性，父元件的屬性是父元件的state:\n      // 子元件：\n      // return <childElement style={props.parentAttribute}>\n      // 父元件：\n      // getStateValue = () => this.state.value\n      // <parentElement style={this.getStateValue}>\n// 2.使用e.target.value取得\n      // 子元件：\n      // return <childInput></childInput>\n      // 父元件：\n      // getValue = (event) => console.log(event.target.value)    \n      // <parentInput onClick={this.getValue}>\n// 3.使用refs\n      // 子元件：\n      // <childInput ref={props.getRefHandler}/>\n      // 父元件：\n      // getRef = (element) => this.inputElement = element\n      // console.log(inputElemnt)\n      // <parentInput getRefHandler={this.getRef}/>  "]},"metadata":{},"sourceType":"module"}